хук useState в функциональном компоненте если имеет несколько ключей в обьекте по типу {products:...,tasks:...}
то нужно чтобы копировать весь стейт {...state,products:...} чтобы установить правильно!
хук useState если у нас два стейта для tasks, и для products если мы вызовем зададим одно временно setTasks,
и setProducts перерисовка компонента пройзойдет один раз, все нормально

хук useEffect срабатывает моментально как только изменится за тем кем он следит, или при рендере;

в классовом компонент когда в стейте находится несколько ключей {products:...,tasks:...}, не нужно
копировать весь стейт достаточно лишь взять новый ключ и установить в него новые значение
this.setState({products:...}) ---> ключ task копировать не нужно он не удалиться, как в useState
this.state={products,names}--setState  === [products,setProducts] [names,setNames] -useState

хук useRef сохраняет состояние определенного чего-то, но не перерисовывает компонент при изменения состояния,
при этом в состояние имеет ключ current ключ.current которым можно узнать текущее состояние и можно сделать
ключ.current.focus() чтобы на ключе выбранного рефа появился фокус
так же стоит помнить если мы создали ref к примеру {task1:0,task2:0} и этому рефу присвоим .current = любой state
и он в этот момент он изменился, в этом рефе сохранится прошлое состояние работает только со стейтами,
а так без стейтов все норм!

хук useMemo как useEffect только, useMemo не вызывается при рендеринге если то значение, те зависимости над
которыми он следит не изменились, а useEffect вызывается при рендеринге даже если обьект не изменился
useMemo кэширует вообщем значения.
const tasks = useMemo(()=>{return кэшируемое значение},[за чем следить])

useCallback тоже самое что useMemo но useMemo используем для каких-то значений определенных, а useCallback
для функций, то есть функция не будет восприниматься как новая если, за тем чем это хук следит не изменился,
кэширует функцию
примеры:
при рендере они не сработают если коунт не изменился!
const kekMemo = useMemo(()=> функциячтотоделаетс(count),[count])
const kekCallback = useCallback((1)=> return count+1,[count])
kekcallback(2) можно вызвать потом

useContext
решает проблему с передачей кучей пропсов в разные компоненты, чтоб от компонента в компонент не передавать вообщем)
для этого нужен провайдер как контейнер для приложения в принципе тоже самое который имеет один пропс value
вот туда передаем в виде обьекте наши функции стейты, итд потом внутри компонентов импортируем useContext(имя провайдера)
в переменную сохраняем и у этой переменной по ключу можно брать те или иные значения!
<></> === React.fragment

